{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Splice creates generative art for the NFT metaverse","text":"<p>NFTs make great profile pictures. Showing off your NFT as a profile picture, preferably on Discord, makes you part of the gang! Large communities grow around NFT collections,  and invent derivative value - like elementary pet companions for cool cats, derivative works on BAYC or Doge puppies.</p> <p>These derivative elements can form a metaverse where NFT communities flourish \u2013 a world of playspaces, workplaces, games, weapons, tools, accessories etc. So that's a great vision, but currently there aren't good tools to make it happen.</p> <p>That's where Splice comes in.</p> <p>Splice generates building blocks for metaverse creation. When you input your NFT, Splice extracts its features and metadata to seed a new derivative work of art. The most obvious and immediate usecase: header images for places like Twitter and Discord, where the NFT community currently gathers. Anyone who owns an NFT can create a matching header image on Splice.</p>"},{"location":"#how-it-works","title":"How it works","text":"<p>First, you choose an NFT that you already own. In theory that can be any NFT, but PFP collections like Cool Cats, Doodles or Bored Apes work best. </p> <p>Next, Splice extracts the dominant colors of that NFT's palette, and computes a random number by combining the origin collection's contract address and the input token's id. This random number defines unique qualities of the generated art (e.g. the position of shapes on the canvas, thickness of line stroke, etc.)</p> <p></p> <p>Finally, you choose an art style from a selection of styles created by various generative artists. Splice seeds that style with your NFT's palette and random number to generate a new work of art.</p> <p>To recreate the artwork for a minted Splice token, one simply extracts the origin information and the chosen style id, downloads the style NFT code from IPFS and recreates the rendering in another browser window. </p> <p></p> <p>Splices are immutable by design. The code for generative styles is stored on a tamper-proof and unstoppable storage layer (IPFS) and the generative art relies on deterministically computable input parameters. </p>"},{"location":"#our-vision","title":"Our Vision","text":"<p>Minting header images is just how Splice gets started. Under the hood it can do much more than that. Our smart contracts accept more than one origin NFT, so generative artists can write code that combines two (or more) NFT seeds to breed something completely new. </p> <p>And it's not restricted to PFP collections. Artists could use the Splice protocol to combine a Decentraland estate, a Cool Cat and a Loot token to create a dedicated artwork, a background story or a new character of a cat adventure game. Building this kind of game mechanic usually requires a lot of individual coding, but Splice lowers the barrier to entry by verifying proof of ownership of a seed NFT, and giving artists an easy tool to write code that responds to a seed NFT's origin traits and attributes.</p>"},{"location":"artists/","title":"Splice for artists","text":"<p>If you're a generative artist interested in creating a Splice style NFT, welcome! Below is an outline of how Splice works, and how we can work together. If you have questions that remain unanswered, or if you want to get started building with Splice, please don't hesitate to contact us on our discord. </p>"},{"location":"artists/#writing-style-code","title":"Writing style code","text":"<p>We're currently supporting style code that has been written using the p5 library. All styles follow the same boilerplate:</p> <p><pre><code>import p5Types from 'p5';\n\ntype RGB = [number, number, number];\n\ninterface DrawProps {\n  p5: p5Types;\n  params: {\n    colors: Array&lt;{\n      color: p5.Color,\n      freq: number, //the overall ratio of this color in the original NFT, e.g. 0.42\n      hex: string, //e.g. #7f9b8b\n      rgb: RGB //the RGB bytes, e.g. [127, 155, 139]\n    }&gt;\n  }\n  dim: { w: number; h: number };\n}\n\nfunction ({ p5, params, dim }: DrawProps) {\n  //your code goes here\n}\n</code></pre> Splice style code mustn't rely on global variables but must use the injected p5 variable which is an initialized p5 rendering context, sized as <code>dim</code>. A few non trivial examples of how to use it can be found in our repository. Note, initially we passed a plain <code>colors</code> array of RGB data into the render function, but that approach is now deprecated. We currently pass along more parameters, that include an array of RGB data, as well as other data like the prevalence of each color.</p> <p>A really simple (but not pretty) example is our flower code:</p> <pre><code>function ({ p5, params, dim }) {\n  const { colors } = params;\n  const primaryColor = colors[0];\n\n  p5.background(primaryColor.color);\n\n  const otherColors = colors.filter((c, i) =&gt; i != 0);\n  // A design for a simple flower\n  p5.translate(dim.w / 2, dim.h / 2);\n  p5.noStroke();\n  for (let i = 0; i &lt; 10; i++) {\n    const color = otherColors[i % otherColors.length];\n    p5.fill(color.color);\n    p5.ellipse(0, 0, 50, dim.w / 1.2);\n    p5.rotate(p5.PI / 10);\n  }\n  p5.noLoop();\n}\n</code></pre>"},{"location":"artists/#ownership-and-deployment","title":"Ownership and deployment","text":"<p>Styles on Splice are minted as NFTs that can be bought and sold. All fees that accrue when collectors mint Splices, or sell minted results on secondary markets, will be escrowed for the current style NFT owner and can be claimed / withdrawn at any time. </p> <p>When deploying a style, its metadata and code is stored on IPFS. Right now, artists rely on a trusted style minter to deploy style NFTs on their behalf. Once minted an artist can sell or transfer their style NFT. A style NFT isn't just a new kind of asset that potentially generates a stream of revenue from primary and secondary sales, but more importantly, a new way for artists to benefit from their work.</p>"},{"location":"artists/#commissions-and-fee-distribution","title":"Commissions and fee distribution","text":"<p>The Splice contract distributes 85% of primary sales to the artist (or whoever owns the style NFT) and 15% to the platform protocol. On secondary sales, the artist (or whoever owns the style NFT) receives 90% of the selected royalty commission (set to 10% on OpenSea).</p> <p>The Splice contract implements the EIP-2981 NFT Royalty Standard that signals secondary marketplaces who should receive royalties. EIP 2981 is a rather new, non-binding way that's not picked up by major platforms like OpenSea yet but likely will lead the effort to streamline royalty payments. </p> <p>All royalty payouts that happen to be paid to the contract owner directly (which is the Splice protocol) in the old-fashioned way will be forwarded to artists on a monthly basis.</p> <p>For security reasons, all fees are kept safe by an inline trustless escrow. It pays out all accrued funds on request (see <code>Splice.sol:claimShares</code>) </p>"},{"location":"artists/#how-to-get-your-style-algorithm-on-splice","title":"How to get your style algorithm on Splice","text":"<p>After you've written and tested your code, we'll get it onto Splice once you sent us the following: </p> <ul> <li>Your ethereum wallet address that will become the initial owner of the style NFT (and receives minting fees)</li> <li>Your style source code</li> <li>The desired cap on your series (how many can be minted)</li> <li>The minting price (in Eth) that you're charging </li> <li>a metadata JSON file like this one:  </li> </ul> <pre><code>{\n  \"name\": \"District 1618\",\n  \"description\": \"District 1618 generates a pattern based on the droste effect and golden mean (1.618).\", \n  \"properties\": {}, \n  \"splice\": {\n    \"creator_name\": \"Splice Genesis\", \n    \"creator_twitter\": \"https://twitter.com/splicenft\",\n    \"creator_url\": \"https://getsplice.io\", \n    \"code_library\": \"p5.js\", \n    \"code_library_version\": \"1.4.0\",\n    \"license\": \"CC BY-NC-ND 4.0\"\n  } \n}\n</code></pre> <p>Please send an email to us at gm@getsplice.io with all of that information seperated into three files, zipped together and attached. The three files should be:</p> <ol> <li>a textfile with pricing, cap and your wallet address</li> <li>a <code>metadata.json</code> file of metadata in the format above</li> <li>a <code>code.js</code> file with your style code</li> </ol>"},{"location":"artists/#the-creators-playground","title":"The creators' playground","text":"<p>A playground to test style code with arbitrary inputs can be found at https://getsplice.io/#/create. Note that you must switch your wallet to mainnet to use the playground's color extraction features. </p> <p></p>"},{"location":"artists/#complex-style-code","title":"Complex style code","text":"<p>While you could write your style using Typescript, that would add another layer of complexity: the style code itself is instantiated inside a browser context, and if it contains TS, it would  fail to load. If you're building a style using TS, you'll need to make sure  your code is transpiled to Javascript before we can mint it. If you don't want to wrap your head around that, just write styles in plain JS.</p>"},{"location":"developers/","title":"Splice for Developers","text":""},{"location":"developers/#project-setup-tech-stack","title":"Project Setup / Tech Stack","text":"<p>We have structured the Splice codebase as monorepo that can be easily built using pnpm. Most packages require some environment variables to be set, so make sure to scan all <code>README</code>s and <code>.env.sample</code> files in the repo. To run all Splice services and Dapps on your own box, you'll certainly need API keys from Etherscan, NFTPort, nft.storage and Infura. Once you've got your env vars in place, you should be able to simply run </p> <p><pre><code>pnpm install\npnpm -r build\n</code></pre> to build all packages in the correct order. The most relevant dependency graph is <code>dapp|backend &lt;- common &lt;- contracts</code>. The language of choice for all code is Typescript. </p>"},{"location":"developers/#contracts","title":"Contracts","text":"<p>Our smart contracts are written in Solidity 0.8.10 and make heavy use of OpenZeppelin's base contracts. To compile / deploy them on your local machine you can use the local <code>hardhat</code> binary that's part of the package's dependencies. Have a look at the package's README file to get an idea of how to get started and make sure to have a good understanding on Hardhat's tooling.</p>"},{"location":"developers/#randomness","title":"Randomness","text":"<p>Each style relies on a certain randomness that makes its results unique. We're precomputing this entropy seed out of deterministic inputs a minter provides: the origin collection's address and the chosen origin token id. This is the secret formula in pseudocode:</p> <pre><code>randomSeed = uint32(keccak256(abi.encode([origin_address],[origin_token_id])))\n</code></pre> <p>Since most Javascript libraries can only deal with 32 bits of numeric precision we're stripping the least significant 32 bits of the 256 bit long keccak hash. In theory that might lead to collisions but we consider that neglectible because the randomness is only one factor that determines the Splice result.</p>"},{"location":"developers/#provenance","title":"Provenance","text":"<p>The Splice contract has been written with gas efficiency in mind, hence we kept all bookkeeping structures to an absolute minimum. Foremost, Splice is intentionally not inheriting OpenZeppelin's Enumerable base which saves us a lot of gas. Additionally, we're not mapping plain origins to token ids directly, but rather use a provenance hash that allows the contract to figure out if a combination of inputs has been minted before. The provenance hash is computed as</p> <pre><code>bytes32 _provenanceHash = keccak256(\n  abi.encodePacked(origin_collections, origin_token_ids, style_token_id)\n);\n</code></pre> <p>Since the explicit provenances aren't part of the contract's state and Splice owners aren't iterable, a developer who wants to list all available Splices and their origins needs to scan the contract for <code>Mint</code> and <code>Transfer</code> events:</p> Contractfind a splice for an originfind the origin for a Splice <pre><code>emit Minted(\n  keccak256(abi.encode(origin_collections, origin_token_ids)),\n  token_id,\n  style_token_id\n);\n</code></pre> Splice.ts<pre><code>public async findProvenances(\n  collectionAddress: string,\n  tokenId: string\n): Promise&lt;TokenProvenance[]&gt; {\n  const originHash = Splice.originHash(collectionAddress, tokenId);\n\n  const filter = this.contract.filters.Minted(originHash);\n  const mintedEvents = await this.contract.queryFilter(\n    filter,\n    this.deployedAtBlock\n  );\n\n  if (mintedEvents.length === 0) return [];\n  return mintedEvents.map((ev) =&gt; {\n    const { style_token_id, token_id: style_token_token_id } =\n      Splice.tokenIdToStyleAndToken(ev.args.token_id);\n    return {\n      origin_collection: collectionAddress,\n      origin_token_id: ethers.BigNumber.from(tokenId),\n      splice_token_id: ev.args.token_id,\n      style_token_id,\n      style_token_token_id\n    };\n  });\n}\n</code></pre> Splice.ts<pre><code>  public async getProvenance(\n  spliceTokenId: BigNumber\n  ): Promise&lt;TokenProvenance | null&gt; {\n    const bnTokenId: BigNumber =\n      'string' === typeof spliceTokenId\n        ? BigNumber.from(spliceTokenId)\n        : spliceTokenId;\n\n    const filter = this.contract.filters.Minted(null, spliceTokenId);\n    const mintedEvents = await this.contract.queryFilter(\n      filter,\n      this.deployedAtBlock\n    );\n    if (mintedEvents.length == 0) return null;\n\n    if (mintedEvents.length &gt; 1)\n      throw new Error('a token can only be minted once');\n\n    const mintEvent = mintedEvents[0];\n    const tx = await mintEvent.getTransaction();\n    const inputData = this.contract.interface.decodeFunctionData(\n      this.contract.interface.functions[\n        'mint(address[],uint256[],uint32,bytes32[],bytes)'\n      ],\n      tx.data\n    );\n\n    const { style_token_id, token_id: style_token_token_id } =\n      Splice.tokenIdToStyleAndToken(spliceTokenId);\n\n    return {\n      origin_collection: inputData.origin_collections[0],\n      origin_token_id: inputData.origin_token_ids[0],\n      splice_token_id: bnTokenId,\n      style_token_id,\n      style_token_token_id\n    };\n  }\n</code></pre> <p>This obviously will become very expensive in terms of RPC requests and latency so we've created a Subgraph that does all this heavylifting for you. Find out more about subgraph usage in the Subgraph section.</p>"},{"location":"developers/#token-ids","title":"Token IDs","text":"<p>You might've wondered why Splice's token ids seem to be so \"big\" and unpredictable (e.g. <code>4294967298</code>). Truth is: that's only because you're looking at them from a human perspective :). Like many other generative art collections we've decided to make the unique token id a combination of style id and an incremental token number. In Splice's case we're thinking big and use the full range of uint32 for both components. </p> <p>Hence, a token id is represented as an <code>Uint64</code> value with its higher significant 32 bits being the style token id (e.g. <code>0x00000001</code>) and the lower 32 bits representing the incremental part. The above mentioned token id is actually the decimal representation of the hexadecimal number (padded to 64 bits) <code>0x0000000100000002</code></p> <pre><code>ethers.utils.zeroPad(ethers.BigNumber.from(\"4294967298\").toHexString(), 8)\n// Uint8Array(8) [\n//  0, 0, 0, 1,\n//  0, 0, 0, 2\n// ]\n</code></pre>"},{"location":"developers/#style-features","title":"Style Features","text":""},{"location":"developers/#collection-constraints","title":"Collection constraints","text":"<p>The owner of a style token may choose to restrict minting of their style to certain origin collections using the style contract's <code>restrictToCollections</code> method. That feature particularly makes sense when the artist had a certain collection in mind when creating their style. </p>"},{"location":"developers/#allowlists","title":"Allowlists","text":"<p>We've added an allowlist feature to our style contract that makes it possible for an artist (or whoever mints an artist's style) to reserve mints for friends, family or a community. That way an artist can set a low cap for a style (like cap of 500), but still be sure certain collectors get access to mint before her collection's sold out.</p> <p>Instead of going with a plain allowlist array we decided to make use of Merkle tree proofs. We haven't implemented a nice snapshotting / tree creation tool as of now, but you can checkout the <code>contracts</code> packages' <code>allowlist.test.ts</code> tests to see how it's supposed to work. </p>"},{"location":"developers/#dynamic-pricing","title":"Dynamic Pricing","text":"<p>The first styles we're launching will require a static minting fee that's set by the style minter role who mints the style NFT on behalf of an artist. We plan to implement more sophisticated approaches to pricing of mints, including Dutch auctions, bonding curves or even oracle based price indicators based on a collection's current floor price. </p> <p>To be flexible in terms of mint price indication we've decoupled price computations from the main contracts: upon minting the style minter decides which pricing strategy should be in effect for the new style. Each strategy is implemented as a dedicated smart contract that must implement the <code>ISplicePriceStrategy</code> interface to return a price denoted in wei: </p> <pre><code>interface ISplicePriceStrategy {\n  function quote(\n    uint256 style_token_id,\n    IERC721[] memory collections,\n    uint256[] memory token_ids\n  ) external view returns (uint256);\n}\n</code></pre> <p>Each style NFT is parametrized with a pricing contract address when minted. That contract is responsible for determining the price point for a requested Splice mint. A basic example is <code>SplicePriceStrategyStatic.sol</code> that returns a fixed price unique to each style token.</p>"},{"location":"developers/#subgraphs","title":"Subgraphs","text":"<p>We've built the splice contract as gas efficient as possible, reducing bookkeeping on chain to a minimum: each splice NFT contains a hash to quickly prove its origins and the style token id that had been chosen for minting. As mentioned in the Provenance section, the <code>subgraph</code> package contains a subgraph definition that's deployed on The Graph protocol's hosted service. It reads all <code>Mint</code> and <code>Transfer</code> events, extracts the minting parameters by using the transaction inputs, and provides a GraphQL API to query certain aspects of the Splice contracts' current state. Here's an example of how to get all splices of an user:</p> GQL QueryResult <pre><code>query SplicesOfOwner($owner: String) {\n    spliceice(where: { owner: $owner }) {\n      id\n      metadata_url\n      style {\n        id\n        metadata_url\n      }\n      origin_collection\n      origin_token_id\n      origin_metadata_url\n    }\n  }\n</code></pre> <pre><code>{\n  \"data\": {\n    \"spliceice\": [\n      {\n        \"id\": \"4294967298\",\n        \"metadata_url\": \"https://validate.getsplice.io/splice/4/4294967298\",\n        \"origin_collection\": \"0xf5aa8981e44a0f218b260c99f9c89ff7c833d36e\",\n        \"origin_metadata_url\": \"https://api.coolcatsnft.com/cat/26\",\n        \"origin_token_id\": \"26\",\n        \"style\": {\n          \"id\": \"1\",\n          \"metadata_url\": \"ipfs://bafyreiedlvkrjowkrs6u74ogyritsfaitsanhujzbciyaoedg33fndbxuu/metadata.json\"\n        }\n      },\n      ...\n    ]\n  }\n}\n</code></pre>"},{"location":"developers/#common-package","title":"Common package","text":"<p>The <code>common</code> package contains code that's shared between our Dapp and the backend. Most importantly we make sure serverside and frontend renderers use exactly the same code so as not to confuse users with varying visual results. </p> <p>Other exports that are exposed by the <code>common</code> package are</p> <ul> <li> <p><code>Splice.ts</code>: a contract class that wraps a typechain-typed instance of an ethers based Splice contract interface and adds some convenience methods to interact with it. </p> </li> <li> <p><code>Style.ts</code>: manages a style's code and wraps it into an executable JS function</p> </li> <li> <p><code>types/NFTs</code>: contains type definitions for NFT metadata and secondary services.</p> </li> <li> <p><code>indexers</code>: contains code to read existing NFTs from chain and extract their metadata in an abstract way: if you know which collections you'd like to read and you have access to a web3 provider, you can use the <code>OnChain</code> indexer. If you need to find all assets owned by an user on mainnet, you can use the <code>NFTPort</code> indexer class instead. Our dapp uses the <code>Fallback</code> indexer that tries reading from NFTPort and falls back to the on chain implementation if NFTPort hasn't fully indexed the collection yet.</p> </li> </ul>"},{"location":"developers/#colors","title":"Colors","text":"<p>The <code>colors</code> package contains code to extract primary / dominant colors from an image. We experimented with quite a lot of solutions but found that some algorithms implemented by the image-q library yield the best results. Color extraction is a pretty delicate field since it deals with image quantization and adaptive weighting under the hood, not unrelated to palette generators. Splice uses a combination of Xiaolin Wu's matrix quantizer and Euclidean color distance to build a palette of 10 primary colors.</p> <p>If you look at the <code>colors/src/index.ts</code> file you'll notice that the same code to compute an image's dominant colors is used on the frontend (<code>dapp/src/components/organisms/CreativePanel:extractPixels</code>) and on the backend (<code>backend/src/lib/Origin.ts</code>).</p>"},{"location":"developers/#backend","title":"Backend","text":"<p>Splice generally doesn't depend on a backend at all: since styles and their code are stored on IPFS and one can recover origin minting parameters by scanning transaction parameters on the Splice contract, you can rebuild your Splice NFT anytime. (We'll be providing dedicated tools for fully trustless rebuilding soon). </p> <p>Since IPFS lookups and chain queries are usually related to high latencies or aren't free (Infura's free tier is high, but their RPC timeouts are rather low), we're providing a backend service that speeds up many use cases significantly.</p> <p>Our backend package is a rather plain express server that responds to 6 API endpoints (see <code>backend/src/server.ts</code>) and its base URI is <code>https://validate.getsplice.io</code>:</p> <ul> <li><code>GET /styles/:network</code> returns all styles (without code) including their metadata that are deployed on <code>network</code> (e.g. <code>4</code> for <code>rinkeby</code>)</li> <li><code>GET /render/:network/:style_token_id</code> renders a grayscale preview of a style.</li> <li><code>GET /styles/:network/:style_token_id</code> returns metadata and inline code of a style token</li> <li><code>GET /splice/:network/:tokenid</code> returns the metadata for Splice <code>tokenid</code></li> <li><code>GET /splice/:network/:tokenid/image.png</code> returns the Splice image for <code>tokenid</code> on <code>network</code></li> <li><code>GET /colors/:network/:collection/:token_id</code> extracts metadata, features and colors of the given NFT.</li> </ul> <p>What makes the backend so powerful is its builtin caching mechanism: Instead of fetching origins, extracting colors and rerendering NFT metadata on every request, we're caching all results once they have been created for the first time. There's an open issue to align the cache layout in a way that's suitable for simple style freezing, too. </p>"},{"location":"developers/#dapp","title":"Dapp","text":"<p>Our dapp is building on a plain and simple CRA + Typescript foundation. We're using Chakra UI for dynamic styling and inject the most important dependencies using a shared context provider (see <code>dapp/src/context/SpliceContext.tsx</code>). You can start the CRA dev server as you're used to:</p> <pre><code>pnpm run start\n</code></pre> <p>An important word of notice: since we're trying to adhere to web3 principles as closely as possible, the build output is hosted on a decentralized network. We don't want to bother with IPNS and DNSLink details, and that's why we've decided to hand over the final build and deployment process to the awesome services of Fleek.co</p>"},{"location":"faqs/","title":"FAQs","text":""},{"location":"faqs/#general","title":"General","text":""},{"location":"faqs/#why","title":"Why?","text":"<p>First, it's fun. Second, it makes absolute sense. Third, being a finalist at an EthOnline hackathon somewhat forces you to continue going after an idea. </p>"},{"location":"faqs/#wen-mainnet","title":"Wen mainnet?","text":"<p>Very soon. We first must collect some feedback, build at least a tiny community that we can ask for their opinions and then we're more than prepared to launch Splice on the most expensive blockchain out there.</p>"},{"location":"faqs/#ok-wen-l2","title":"Ok, wen L2?","text":"<p>That's the right question! Splice actually is pretty special: you can only mint a Splice when our contract can prove that you're owning the origins. So, we easily could just deploy Splice on Optimism or Polygon but without taking any other measures that would restrict it to mint only on these networks. ERC721 bridging and (multi?-) cross chain messaging is a problem class of its own, to be honest. While we have thought about quite thoroughly, we haven't got plans to make this our first priority (but our third).</p>"},{"location":"faqs/#solana-tezos","title":"Solana, Tezos?","text":"<p>Well, no. If you feel like Splice must be a protocol that supports non-EVM chains, join our Discord and discuss it with us. Even better: if you're a seasoned Solana dev, join our team :)</p>"},{"location":"faqs/#styles","title":"Styles","text":""},{"location":"faqs/#im-an-artist-and-i-feel-i-must-write-a-style","title":"I'm an artist and I feel I must write a style.","text":"<p>That's so awesome &lt;3!! Checkout our docs for artists, have a look at the styles that Emily has built during EthOnline (the <code>/renderers</code> folder) and just start tinkering. We're going to provide a sandbox for artists that should make building on splice a breeze. </p>"},{"location":"faqs/#can-i-use-svgs-in-my-styles","title":"Can I use SVGs in my styles?","text":"<p>We never tried it yet, but it should be absolutely possible. Note, that style code will never be able to load external resources, though, so all your dependencies must be embedded in your code base (base64 encoded data urls or svg data should do the trick).</p>"},{"location":"faqs/#can-styles-be-animated","title":"Can styles be animated?","text":"<p>Have you ever seen an animated Twitter banner image?! Ok, in theory: yes, in practice: not too soon (we're disabling the p5.loop outside of the render context).</p>"},{"location":"samples/","title":"that's a page to test advanced MkDocs / Material tools","text":"<p>checkout the official docs:  I didn't activate all of it here, yet.</p>"},{"location":"samples/#testing-some-features","title":"testing some features","text":"<p>fenced code blocks</p> JS is too easy<pre><code>function foo() { \n  return \"boo\"; \n}\n</code></pre> never_learnt_python.py<pre><code>def some_func(word):\n  print(\"python is a language.\")\n  if (q == \"yep\"):\n    print(\"whitespace does matter\")\n\nsome_func(\"foo\")\n</code></pre> <p>but can also do <code>inline code</code>, does it?</p> <pre><code>make: tilde fence marks are also valid\n</code></pre> <p>Heads up</p> <p>This is content for an Admoniton.</p>"},{"location":"samples/#lets-check-tab-grouped-content","title":"Lets check tab grouped  content","text":"SolidityTypescript <pre><code>// contracts/GLDToken.sol\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts/token/ERC20/presets/ERC20PresetMinterPauser.sol';\n\ncontract GLDToken is ERC20PresetMinterPauser {\n  constructor(uint256 initialSupply) ERC20PresetMinterPauser('Gold', 'GLD') {\n    _mint(msg.sender, initialSupply);\n  }\n}\n</code></pre> <pre><code>const q: Record&lt;string, number&gt; = {\n  \"foo\": 1,\n  \"moo\": 2\n}\n\nenum State { POTATO, TOMATO, PEANUT }\n\nclass Mouse {\n  private state: State;\n  constructor(state = POTATO);\n}\n</code></pre>"},{"location":"samples/#but-what-about-tables","title":"But what about tables?","text":"Method Description <code>GET</code> :material-check:     Fetch resource <code>PUT</code> :material-check-all: Update resource <code>DELETE</code> :material-close:     Delete resource"},{"location":"users/","title":"User Guide","text":"<p>Visit our main page and connect a wallet to a supported network. Proceed to the \"My NFTs\" page that displays all NFTs you own on the connected network. On Rinkeby you can mint some selected testnet NFTs free. Note, that in order to make use of Ethereum testnets you'll need some testnet Ether which you can get for free by testnet faucets.</p>"},{"location":"users/#selecting-or-creating-origin-nfts","title":"Selecting or creating origin NFTs","text":"<p>On testnets not all of your collected NFTs may show up. That's due to limitations of the indexers we're using. In fact, on testnets we're only scanning collections that we're aware of for your assets. On Mainnet we're using NFTPort to discover and display all your assets.</p> <p></p>"},{"location":"users/#minting-a-splice","title":"Minting a Splice","text":"<p>Once you've found an NFT you'd like to splice, you head over to its detail page and wait for the image to load. Depending on the origin's pixel dimensions this can take a while because we must load the original artwork (likely to be stored on IPFS) and extract its predominant colors. We're also calculating a seed for the style's random number generator out of the origin collection's address and the origin token's ID.</p> <p>When all deterministic parameters have been extracted you can choose a style for your Splice. We're downloading the chosen style's code from IPFS (in practice we're using a cached version to speed things up), apply the extracted parameters to it and display the rendered result immediately on that page. </p> <p></p> <p>If you like the result, you can decide to mint it as a Splice NFT. Each style may have a different minting cap and pricing strategy, determined by the protocol and the style artist. Our three initial styles use constant minting fees.</p> <p></p>"},{"location":"users/#view-your-splices","title":"View your Splices","text":"<p>You can see all Splices you own when visiting the \"My Splices\" page. It's showing the used style for each item, the computed randomness and the tokenURI the Splice contract yields for a splice.</p> <p></p> <p>You also can view your Splices on marketplace applications, e.g. on OpenSea. Splice derivatives are compatible to the ERC-721 standard and are therefore tradeable like any other NFT asset.</p> <p></p> <p>Splice differs from usual NFT \"collectibles\" as the rarity and scarcity of a style collection can not be predetermined before its minted out (Splice's users are defining the assets themselves). Therefore we cannot rely on IPFS to freeze a splice image immediately after minting (something we actually tried to do in the beginning). Instead, the metadata is hosted / generated on a backend that we're hosting (<code>https://validate.getsplice.io</code>). </p> <p>But that's not really a \"centralized\" tradeoff: since all styles, their code base and your origin NFT (hopefully) are stored on IPFS, you can deterministically recreate your Splice using any modern browser at any time. At the time of writing we haven't enabled the fully decentralized rerendering feature on our page but we're planning to offer a dedicated package that'll enable you to easily recreate all artworks at any time without any dependency on any backend service other than IPFS.</p>"},{"location":"users/#minting-rules-and-provenances","title":"Minting Rules and Provenances","text":"<p>We thought a long time about the best rules on what can be minted. First, it's possible to mint more than one Splice of an origin. For obvious reasons it's not possible to do so using the same style, i.e. the combination of [origin collection - origin token id - style token id] is the unique key that identifies a splice - we also refer to this combination as provenance.</p> <p>On the other hand we've prepared the Splice contract to be future ready: technically it's already possible to use more than one origin NFT as an input. We haven't written style code and style interfaces that make use of this feature yet but that's something that our artists can make use of very soon.</p>"},{"location":"users/#interacting-with-splice-contracts-directly","title":"Interacting with Splice contracts directly","text":"<p>Splice is a public ERC721 contract, so you are encouraged to read its source code or interact with it using your preferred chain explorer or command line tool. We deployed the main Splice contract using OpenZeppelin's upgradeable base contracts and verified its sources on Etherscan as Transparent Proxy. </p> <p></p>"},{"location":"users/#contract-addresses","title":"Contract addresses","text":""},{"location":"users/#rinkeby","title":"Rinkeby","text":"<p>Splice base contract: 0xEa934c468e6c8c0C60E6E62797ae57dBD601970f Splice Style NFT: 0x25a82392fd023f741900a3953468d08246204d5c Static Price Strategy: 0x6c429D0801F18849563A235A046882482a739a3f </p>"},{"location":"users/#roles-and-governance","title":"Roles and Governance","text":"<p>Splice tries to become an open ecosystem for derivative generative art. We discussed a lot about which roles actually should be in charge of deploying new styles or control a styles' settings. We came up with a rather controlled approach that can be loosened for much more decentralized (DAO based) governance in the future.</p>"},{"location":"users/#owner","title":"Owner","text":"<p>Right now all contracts are owned by us as maintainers. The most important right the owner role bears is to pause the Splice contract, effectively disabling new mints and transfers. This is necessary (and a very common practice) to be able to stop operations and upgrade contracts when attackers abuse flaws they found in our source code. Besides that important technical implication, the contract owner bears two additional rights: she can decide which account receives or loses the style minter role. The owner of the Splice protocol also decides about the share of minting fees between artists and the platform beneficiary. </p>"},{"location":"users/#curator","title":"Curator","text":"<p>An account bearing the styke minter role may mint new style NFTs at any time. Style minting is a non trivial and \"dangerous\" task since once minted many characteristics of a style can never be changed again (e.g. the overall cap of a style). We've been orienting on the curation aspects of other generative art platforms here which decide together with their artist which styles will be available to mint on their protocols (e.g. ArtBlocks).</p>"},{"location":"users/#artist","title":"Artist","text":"<p>Artists are writing the generative code for Splice. Their code can only be minted as a style NFT by style minters. Together with their style minter artists decide about the aspects of their style collection: together they decide about pricing and cap (max. amount of mints) of a style. An artist becomes the first owner of a style token after its minted. </p>"},{"location":"users/#style-owner","title":"Style Owner","text":"<p>Users will have to pay a certain fee during the Splice minting process that's split between a platform beneficiary (15%, see below) and the current holder of the style NFT (85%). Since style NFTs are transferrable, that holder is not necessarily the original artist anymore - artists instead can sell their NFT with a forward looking price tag. </p> <p></p>"},{"location":"users/#platform-beneficiary","title":"Platform Beneficiary","text":"<p>Splice takes a 15% share of all minting fees. Instead of simply sending that cut to the owner of all Splice contracts we instead decided to introduce a dedicated platform beneficiary role that's allowed to withdraw the platform cut. This allows us to seperate monetary concerns from technical ones (even though currently the owner is able to denominate the beneficiary).</p>"},{"location":"users/#withdrawing-funds","title":"Withdrawing funds","text":"<p>Minting fees are not transferred to the beneficiaries upon minting. Instead we're following well known and recommended best practices and make use of an internal fee escrow that accrues funds on behalf of the beneficiaries. Each role that's eligible and got funds on it may withdraw them at any time by calling the <code>Splice.withdrawShares</code> method (but beware that this needs a small amount of Eth on the caller's side to pay for gas).</p>"},{"location":"users/#freezing-styles","title":"Freezing styles","text":"<p>We have implemented a freeze feature on the style contract that can be called by style minters when the cap of a collection has been reached (i.e. it's fully minted). The style minter will first have to create a directory containing all metadata and splice renderings and add (ideally pin) it to IPFS. The resulting directory hash is then used by the Splice contract's <code>tokenURI</code> method. Frozen styles cannot be unfrozen again so all metadata can be considered final and unchangeable from that point.</p>"},{"location":"vision/","title":"Vision","text":""},{"location":"vision/#additional-ideas-short-term","title":"Additional ideas, short term","text":"<p>We're capping the minting of tokens on an input collection basis. You can't mint as many backgrounds as there are tokens in the origin collection. </p> <p>Requestors must pay a minting fee that's used to </p> <ul> <li>pay the oracle fees (LINK)</li> <li>pay royalties to the style artist (sent to the current owner of the style NFT)</li> <li>give back a share to the origin collection (since we're deriving from their original idea)</li> <li>keep a small share to our own DAO</li> </ul> <p>Once the original piece is sold, the contract transfers the background ownership, too (if this should happen automatically we need some hook that the origin NFT contracts can call back, adding gas fees to their transfer tx)</p>"},{"location":"vision/#mid-term","title":"mid term","text":"<p>the minting fee can be dynamic, using a bonding curve that takes several aspects into account:</p> <ul> <li>the current market price of the requestor's NFT (need an oracle that signals the collection's floor price or, even better, a floor for the tier of the origin NFT (some cats are cooler than others) ). This could be achieved by utilizing rarity.tools as one source for oracle data</li> <li>the background collection's current supply: later pieces are more expensive</li> <li>a fee that's defined by the style artist</li> </ul> <p>If we were to add this, we might define a cap on that fee or (reverse?) auction it proportionally to the time the collection is part of Splice.</p>"}]}